# -*- coding: utf-8 -*-
"""Piyavsky.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10-z4d2qEbyd_iOT-fKP9pCEjgrGdlfcZ
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from tqdm import tqdm
# %pylab inline

class Piyavsky():

    def __init__(self, func, a, b, n, L_mult = 1.5):
        assert a != b, 'Концы отрезка должны иметь разные абсциссы'

        self.func = func
        self.a = a
        self.b = b
        self.n = n
        self.L_mult = L_mult
        self.h = (self.b-self.a)/self.n
        self.x_grid = [self.a + self.h * i for i in range(self.n)]
        self.x_grid.append(self.b)

    def _L(self):
        '''
        Оценка конастанты Липшица
        '''
        self.func_values = np.array([self.func(x = x) for x in self.x_grid])
        df_dx = (self.func_values[1:] - self.func_values[:-1])/self.h
        L_est = np.max(df_dx)
        return L_est*self.L_mult

    def _compute_intersection(self, l, r):
        '''
        Расчет точки пересечения ветви модуля с минорантой
        '''
        x = (l[1] - r[1]) / (2 * self.lip_const) + (l[0] + r[0]) / 2
        y = l[1] - (x - l[0]) * self.lip_const
        return np.array([x, y])

    def _find_neighbors(self, x):
        '''
        Нахождение соседних вершин миноранты
        '''
        dists_x = self.peaks[:,0] - x
        min_dists_idxs = np.argsort(np.abs(dists_x))[1:3]
        left = self.peaks[min_dists_idxs[0]]
        right = self.peaks[min_dists_idxs[1]]
        if left[0] > right[0]:
            left, right = right, left
        return np.vstack((left, right))

    def fit(self, eps, k_max):
        '''Построение миноранты с заданной точностью или с заданным кол-вом итераций'''

        #Массив максимумов миноратны нв функции. Изначально там граничные точки.
        self.peaks = np.array([[self.a, self.func(x = self.a)], [self.b, self.func(x = self.b)]])

        #Вычисляем константу Липшица
        self.lip_const = self._L()

        #zero iteration
        self.candidates = self._compute_intersection(self.peaks[0], self.peaks[1]).reshape(1,2)
        self.diff = np.inf

        for k in tqdm(range(1, k_max)):
            if self.diff < eps:
                print(f'Разница между функцией и минимумом миноранты стала меньше eps и достигла {self.diff}')
                break

            min_id = np.argmin(self.candidates, axis = 0)[1]
            self.min_candidate = self.candidates[min_id]

            self.diff = np.abs(self.func(x = self.min_candidate[0]) - self.min_candidate[1])

            new_peak = np.array([self.min_candidate[0], self.func(x = self.min_candidate[0])])
            self.peaks = np.vstack((self.peaks, new_peak))

            neighbors = self._find_neighbors(new_peak[0])
            self.candidates = np.vstack((self.candidates, self._compute_intersection(neighbors[0], new_peak)))
            self.candidates = np.vstack((self.candidates, self._compute_intersection(new_peak, neighbors[1])))

            self.candidates = np.delete(self.candidates, min_id, 0)
        else:
            print('Достигнуто максимальное количество итераций')
            print(f'Разница между функцией и минимумом миноранты достигла {self.diff}')
        return self.min_candidate

    def print_results(self, name, x_title = 'X', y_title = 'Y'):
        data = np.vstack((self.peaks, self.candidates))
        sort_idxs = np.argsort(data, axis = 0)[:,0]
        data_ = data[sort_idxs]
        x = data_[:,0]
        y = data_[:,1]
        f = [self.func(x=i) for i in self.x_grid[::2]]
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=self.x_grid[::2], y=f,
                            mode='lines',
                            name='Function'))
        fig.add_trace(go.Scatter(x=x, y=y,
                            mode='lines',
                            name='Minorant'))
        fig.add_trace(go.Scatter(
            x=[self.min_candidate[0]],
            y=[self.min_candidate[1]],
            marker=dict(color="crimson", size=12),
            mode="markers",
            name="Minimum",
        ))
        fig.update_layout(
            title=name,
            xaxis_title=x_title,
            yaxis_title=y_title
            )
        return fig
